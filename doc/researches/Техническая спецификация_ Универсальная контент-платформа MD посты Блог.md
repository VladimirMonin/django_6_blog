# **Техническая спецификация: Универсальная контент-платформа MD посты Блог**

## **1. Введение и Философия**

Цель проекта — создание масштабируемой, отказоустойчивой платформы для публикации контента, который может гибко трансформироваться из публичных статей блога в структурированные уроки образовательных курсов без дублирования данных.  
**Ключевые архитектурные принципы:**

1. Атомарность и Полиморфизм контента:  
   Единица контента (Пост) рассматривается как универсальный "атом" информации. В зависимости от контекста и метаданных, этот атом может проявляться как SEO-оптимизированная статья, закрытый урок курса, часть документации или новостная заметка. Это исключает необходимость миграции данных при смене бизнес-модели (например, при переходе от блога к онлайн-школе).  
2. Post-Centric Media (Изоляция ресурсов):  
   Мы отказываемся от концепции "общей медиа-библиотеки" (как в WordPress), которая со временем превращается в неконтролируемую свалку файлов. Все медиа-ресурсы (изображения, видео, аудио) жестко привязаны к конкретному посту через внешний ключ.  
   * **Преимущество:** При удалении поста мы точно знаем, какие файлы можно безопасно удалить, освобождая место в S3.  
   * **Порядок:** Файловая структура на диске/S3 повторяет структуру контента, а не дату загрузки.  
3. Markdown First (Чистые данные):  
   База данных хранит контент в формате "чистого" Markdown, а не загрязненного HTML.  
   * **Безопасность:** Исходный текст безопасен, XSS-уязвимости отсекаются на этапе рендеринга.  
   * **Гибкость:** Мы можем сменить CSS-фреймворк (например, с Bootstrap на Tailwind) или дизайн плееров, просто изменив шаблон рендеринга, без необходимости парсить и переписывать гигабайты HTML в базе данных.  
   * **Портативность:** Текст легко экспортировать обратно в файлы для бэкапа или миграции.  
4. Cloud-Native & S3-Ready:  
   Архитектура изначально проектируется с расчетом на внешнее объектное хранилище (Timeweb S3, AWS). Это означает полный запрет на использование локальных путей в коде и базе данных. Ссылки формируются динамически, что позволяет менять провайдера хранилища "на лету" простым изменением конфигурации settings.py.

## **2. Архитектура Данных (Модели)**

### **2.1. Модель Post (Универсальная единица контента)**

Центральная сущность системы. Спроектирована с запасом прочности для трансформации в LMS (Learning Management System).  
**Основные атрибуты:**

* **Заголовок (Title):** Текстовое поле, используемое в H1 и meta-title.  
* **Slug (URL-адрес):** Уникальный идентификатор.  
  * *Требование:* Должен генерироваться автоматически из заголовка с транслитерацией (кириллица -> латиница).  
  * *Обработка коллизий:* Если слаг занят, к нему автоматически добавляется числовой суффикс (например, django-tutorial-2).  
* **Автор (Author):** Ссылка на модель пользователя. В контексте LMS это поле будет обозначать преподавателя или куратора конкретного урока.  
* **Контент (Body):** TextField, хранящий исходный код Markdown. Поддержка расширенного синтаксиса (таблицы, сноски, блоки кода с подсветкой).  
* **Аннотация (Excerpt):** Краткое содержание (150-300 символов).  
  * *Использование:* Meta description, превью в карточках соцсетей (OpenGraph), краткое описание урока в списке модулей курса.  
  * *Автогенерация:* Если не заполнено вручную, генерируется из первого абзаца контента.  
* **Обложка (Cover):** Ссылка на объект PostMedia.  
  * *Fallback:* Если обложка не задана, система должна использовать CSS-генератор градиентов на основе ID поста или дефолтное изображение категории.

**Управление жизненным циклом и доступом (LMS-ready):**  
Использование Django Permissions для фильтрации контента в высоконагруженных списках неэффективно. Мы используем денормализованные поля статусов для быстрых SQL-запросов (WHERE status = 'published').

* **Статус жизненного цикла (status):**  
  * *Черновик (Draft):* Виден только автору и администраторам. Используется в процессе написания.  
  * *На модерации (Review):* Сигнал редактору о готовности материала (важно для командной работы).  
  * *Опубликован (Published):* Материал доступен согласно правам доступа.  
  * *Архив (Archived):* Материал скрыт из списков, но доступен по прямой ссылке (важно для сохранения SEO-веса старых страниц, которые не стоит удалять полностью).  
* **Уровень доступа (access_level):**  
  * *Публичный (Free):* Стандартная статья блога. Доступна гостям и поисковым роботам.  
  * *Только для зарегистрированных (Member-only):* Лид-магнит. Пользователь видит заголовок и аннотацию, но для чтения полного текста требуется регистрация.  
  * *Приватный/Платный (Paid/Course):* Урок курса. Полностью скрыт из общей ленты блога. Доступ проверяется через наличие покупки связанного продукта (Курса).

**Метрики и Социальное взаимодействие:**

* **Счетчик просмотров (views_count):** Инкрементальное поле.  
  * *Оптимизация:* Обновляется не чаще 1 раза в N минут для одного IP или сессии, чтобы избежать накрутки и блокировок базы при записи.  
* **Средний рейтинг (rating):** Денормализованное поле (Float, 1.0–5.0).  
  * *Логика:* Пересчитывается асинхронно или по сигналу при добавлении новой оценки. Позволяет сортировать "Лучшие материалы" без тяжелых агрегационных запросов к БД.

### **2.2. Модель PostMedia (Универсальный медиа-контейнер)**

Обертка вокруг физического файла. Решает проблему разнообразия форматов и обеспечивает "умное" поведение медиа.  
**Атрибуты:**

* **Связь с Постом (post):** ForeignKey с on_delete=models.SET_NULL.  
  * *Логика:* При удалении поста файлы не удаляются мгновенно (защита от случайной потери данных). Они помечаются как "сироты" (post_id=None) и могут быть очищены фоновой задачей спустя 30 дней.  
* **Файл (file):** Поле FileField (не ImageField, чтобы избежать валидации Pillow для видео/аудио файлов).  
* **Тип медиа (media_type):** Enum (Image, Audio, Video, Document).  
  * *Автоматизация:* Вычисляется в методе save() на основе MIME-типа или расширения файла.  
* **Оригинальное имя (original_filename):** Хранит имя файла, с которым он был загружен пользователем или импортирован из Obsidian. Критически важно для матчинга ссылок при импорте Markdown.  
* **Безопасный слаг (file_slug):** UUID или хеш. Используется для формирования устойчивых ссылок внутри Markdown, которые не зависят от физического пути к файлу.  
* **Метаданные (meta_data - JSON):**  
  * *Images:* width, height (для предотвращения скачков верстки - CLS), blurhash (для красивых плейсхолдеров при загрузке).  
  * *Audio/Video:* duration (длительность), bitrate.  
  * *Files:* size (размер в байтах для отображения пользователю).

### **2.3. Модель UserPostRating (Рейтинг)**

Реализация честной системы оценки качества материала.  
**Атрибуты:**

* **Пост:** Ссылка на оцениваемый материал.  
* **Пользователь:** Кто поставил оценку.  
* **Оценка:** Целое число (1-5).  
* **Контроль:** unique_together = ['user', 'post']. Защита от накрутки одним пользователем.

**Логика:** При сохранении/изменении оценки срабатывает сигнал Django (post_save), который запускает пересчет поля Post.rating.

## **3. Стратегия Хранения и Путей (S3 Ready)**

### **3.1. Абстракция файловой системы**

Платформа должна быть агностиком относительно места хранения файлов. Прямые пути файловой системы (например, /var/www/media) запрещены.

* **Уровень приложения:** Весь код взаимодействует с файлами исключительно через Django Storage API.  
* **Конфигурация (Local vs Prod):**  
  * *Dev:* FileSystemStorage — файлы сохраняются локально в папку media/ для удобства отладки.  
  * *Prod:* S3Boto3Storage — драйвер автоматически перехватывает файлы и отправляет их в бакет Timeweb S3.  
* **Структура путей:** uploads/{year}/{month}/{post_uuid}/{filename}.  
  * *Зачем UUID в пути:* Обеспечивает уникальность папки поста и предотвращает коллизии имен файлов, если пользователь загрузит два файла image.png в разные посты. Также усложняет перебор файлов злоумышленниками (enumeration attack).

### **3.2. Ссылки внутри Markdown (Link Portability)**

Главная проблема переездов между хостингами — "битые" ссылки в тексте.

* **Запрет абсолютных ссылок:** В базе данных строго запрещено хранить ссылки вида <https://s3.timeweb.../image.jpg>. При смене провайдера S3 или домена такие ссылки перестанут работать, требуя сложной миграции текста.  
* **Внутренний формат:** Ссылки хранятся в относительном или логическом виде.  
  * *Вариант А (Предпочтительный):* ![](/media/posts/{post_slug}/{file_slug}) — процессор при рендере перехватывает этот путь.  
  * *Вариант Б (Абстрактный):* ![alt](media:{uuid}) — использование кастомного протокола, который резолвится процессором.

## **4. Конвейер Обработки Контента (Render Pipeline)**

Преобразование Markdown в HTML происходит динамически при запросе страницы ("на лету") с использованием многоуровневого кеширования. Это позволяет обновлять дизайн плееров для всех старых постов одновременно, просто изменив код шаблона.  
**Этапы процессора (Markdown Processor):**

1. **Парсинг и Санитизация:**  
   * Текст обрабатывается парсером (например, markdown-it-py или mistune).  
   * **Важно:** Проводится очистка HTML (Sanitization) для удаления потенциально опасных JS-скриптов (защита от XSS), разрешаются только безопасные теги.  
2. **Резолвинг Медиа (Media Resolution):**  
   * Процессор находит все конструкции изображений и ссылок.  
   * Извлекает идентификатор файла (slug/uuid).  
   * Обращается к кешированному списку PostMedia текущего поста.  
3. Генерация HTML-компонентов:  
   В зависимости от media_type найденного файла, генерируется специфичный HTML:  
   * **Image:** Генерируется тег <figure>.  
     * <img> с атрибутами src, alt, width, height (из метаданных JSON для предотвращения CLS).  
     * loading="lazy" для нативной отложенной загрузки.  
     * Классы стилизации (например, img-fluid rounded shadow).  
   * **Audio:** Генерируется HTML5 <audio controls preload="metadata">. Добавляется ссылка на скачивание как fallback.  
   * **Video:** Генерируется <video controls playsinline poster="{cover_url}">.  
   * **Code Blocks:** Применяется подсветка синтаксиса (Pygments или Highlight.js) на стороне сервера или клиента.  
4. Финальная сборка (URL Injection):  
   Для всех сгенерированных медиа-тегов запрашивается актуальный абсолютный URL через метод storage.url(). Это гарантирует, что даже если вчера файлы были локально, а сегодня на S3 — ссылки на сайте будут рабочими.

## **5. Сценарии создания контента (Workflows)**

### **5.1. Ручной режим (Web UI с "Черновиком-призраком")**

Сценарий для комфортного написания лонгридов прямо в браузере. Решает проблему привязки файлов к еще не созданному посту.

1. **Инициализация (Ghost Draft):**  
   * При нажатии "Создать пост" система *немедленно* создает в БД запись со статусом DRAFT и временным заголовком.  
   * Происходит редирект на URL редактирования /editor/{uuid}/. Теперь у поста есть ID, к которому можно привязывать файлы.  
2. **Асинхронная загрузка (Dropzone):**  
   * Интерфейс содержит зону Drag-n-Drop, реализованную на стеке **Django Components + HTMX**.  
   * Загрузка происходит фоном (AJAX/Fetch), без перезагрузки страницы редактора.  
   * Сервер принимает файл, определяет его тип (видео/аудио/фото), сохраняет и возвращает HTML-фрагмент (карточку файла).  
3. **Вставка в текст:**  
   * Пользователь видит карточку загруженного файла с превью.  
   * Кнопка "Копировать" помещает в буфер обмена подготовленный Markdown-код (![Описание](file-slug)).  
   * Пользователь вставляет код в нужное место текста.  
4. **Публикация:**  
   * Пользователь заполняет метаданные (SEO, категории).  
   * Меняет статус с "Черновик" на "Опубликовано".

### **5.2. Импорт ZIP (Obsidian Workflow)**

Сценарий для массового переноса базы знаний или офлайн-работы.

1. **Загрузка архива:** Пользователь отправляет ZIP-файл через форму в админке.  
2. **Разбор структуры (Parsing):**  
   * Система распаковывает архив во временную директорию (Memory или TempFS).  
   * Находит файл .md (основной текст) и папку с ресурсами (обычно attachments или корень).  
3. **Обработка Медиа:**  
   * Скрипт проходит по всем медиа-файлам в архиве.  
   * Вычисляет хеш файла (MD5/SHA1) для проверки дубликатов.  
   * Создает объекты PostMedia, физически сохраняя файлы в Storage.  
   * Сохраняет маппинг {original_filename: new_file_slug}.  
4. **Трансформация Текста:**  
   * Парсит содержимое Markdown-файла.  
   * Находит ссылки всех форматов: стандартные ![](img.png) и Obsidian Wiki-links ![[img.png]].  
   * Заменяет их на внутренний формат ссылок, используя созданный маппинг.  
5. **Финализация:** Сохраняет трансформированный текст в Post.content и удаляет временные файлы.

### **5.3. API (Automation & CI/CD)**

Сценарий для headless-управления и интеграции с внешними системами.

1. **Auth:** Доступ по API-ключу или JWT-токену (для администраторов/авторов).  
2. **Endpoints:**  
   * POST /api/posts/: Создание пустого черновика или поста с текстом.  
   * POST /api/posts/{id}/media/: Загрузка медиа-файла (multipart/form-data). Возвращает JSON с объектом медиа, включая готовый Markdown-сниппет для вставки.  
   * PATCH /api/posts/{id}/: Обновление контента поста (например, добавление ссылок на загруженные медиа).

## **6. Перспективы масштабирования (LMS - Learning Management System)**

Текущая архитектура Post + PostMedia является готовым фундаментом для образовательной платформы. Внедрение курсов не потребует переделки существующего кода, а лишь надстройки новых моделей.  
**Стратегия расширения:**

1. **Иерархия Курса:**  
   * **Модель Course:** Продукт, который покупают. Содержит цену, промо-видео, лендинг-описание.  
   * **Модель Module:** Тематический блок внутри курса (например, "Введение", "Базы данных"). Группирует уроки.  
2. **Урок как Пост:**  
   * Создается связующая модель CourseLesson (Through-table), которая связывает Module и Post.  
   * Добавляет поле order (порядок урока в модуле).  
   * **Ключевой момент:** Урок курса — это технически тот же самый Post, у которого:  
     * status = PUBLISHED (он готов).  
     * access_level = PAID (он скрыт из блога и требует прав доступа).  
3. **Прогресс обучения:**  
   * Отдельная модель UserLessonProgress, фиксирующая факт прохождения конкретного урока (Post) конкретным пользователем.

Таким образом, мы достигаем максимальной переиспользуемости кода: плееры, рендеринг markdown, загрузка файлов — всё это работает одинаково и для блога, и для платных курсов.

# Фаза 2.3: Markdown → HTML автоматическая конвертация

## Цель

Реализовать автоматическую конвертацию Markdown в HTML при создании и редактировании постов с сохранением результата в отдельное поле для быстрого рендеринга.

## Контекст

Архитектура решения:

1. Админ пишет пост на Markdown в поле `content`
2. При сохранении поста (метод `save()`) Markdown автоматически конвертируется в HTML
3. HTML сохраняется в поле `content_html`
4. На фронтенде отображается готовый HTML из `content_html`

**Преимущества:**

- Конвертация один раз (при сохранении), а не при каждом просмотре
- Быстрый рендеринг страниц
- SEO-friendly (готовый HTML в базе)
- Чистый HTML без встроенных стилей (подсветка добавится на клиенте)

**Используемые библиотеки:**

- `markdown` — основной парсер Markdown → HTML
- `pymdown-extensions` — расширения (таблицы, footnotes, emoji, admonitions)

**Важно:** Подсветка синтаксиса будет реализована на фронтенде через Highlight.js (Phase 2.4), поэтому Pygments не используется для генерации HTML

## Задачи

### 1. Установка зависимостей

- [ ] Установить `markdown` через Poetry
- [ ] Установить `pymdown-extensions` для расширенных возможностей
- [ ] Проверить установленные версии через `poetry show`

### 2. Добавление поля content_html в модель Post

- [ ] Открыть `blog/models.py`
- [ ] Добавить новое поле `content_html`:
  - Тип: `TextField`
  - Параметры: `blank=True`, `editable=False`
  - verbose_name: "HTML контент"
  - help_text: "Автоматически генерируется из Markdown"
- [ ] Убедиться, что поле не редактируется в админке (`editable=False`)

### 3. Создание функции конвертации Markdown

- [ ] В файле `blog/models.py` создать функцию `convert_markdown_to_html()`:
  - Принимает markdown_text как параметр
  - Использует библиотеку `markdown.markdown()`
  - Настраивает расширения (extensions)
  - Возвращает HTML строку
- [ ] Настроить расширения Markdown:
  - `extra` — таблицы, footnotes
  - `fenced_code` — блоки кода с тройными backticks
  - `tables` — таблицы
  - `nl2br` — переносы строк → `<br>`
  - `codehilite` с `use_pygments=False` — для `class="language-X"` (Highlight.js)
  - `pymdownx.superfences` — улучшенные code blocks с поддержкой Mermaid
  - `pymdownx.emoji` — поддержка эмодзи (опционально)
  - `pymdownx.tasklist` — чекбоксы в списках (опционально)
- [ ] Настроить конфигурацию `codehilite`:
  - `use_pygments: False` — НЕ генерируем HTML с Pygments
  - `guess_lang: True` — автоопределение языка
  - `lang_prefix: "language-"` — формат для Highlight.js

### 4. Переопределение метода save() в модели Post

- [ ] В классе `Post` переопределить метод `save()`
- [ ] Добавить логику конвертации Markdown → HTML:
  - Проверить, что поле `content` не пустое
  - Вызвать функцию `convert_markdown_to_html(self.content)`
  - Сохранить результат в `self.content_html`
  - Вызвать родительский `super().save(*args, **kwargs)`
- [ ] Добавить обработку исключений при конвертации

### 5. Создание и применение миграции

- [ ] Создать миграцию для нового поля:
  - `python manage.py makemigrations`
- [ ] Проверить созданную миграцию в `blog/migrations/`
- [ ] Применить миграцию:
  - `python manage.py migrate`
- [ ] Убедиться, что миграция прошла успешно

### 6. Создание data migration для существующих постов

- [ ] Создать пустую миграцию для данных:
  - `python manage.py makemigrations --empty blog --name convert_existing_posts_to_html`
- [ ] Открыть созданный файл миграции
- [ ] Добавить функцию `convert_posts()`:
  - Получить все посты из базы
  - Для каждого поста конвертировать `content` → `content_html`
  - Сохранить пост
- [ ] Добавить обратную функцию для отката (пустая или очистка content_html)
- [ ] Применить data migration:
  - `python manage.py migrate`

### 7. Обновление шаблона post_detail для отображения HTML

- [ ] Открыть `templates/blog/post_detail.html`
- [ ] Найти строку с отображением контента: `{{ post.content|linebreaks }}`
- [ ] Заменить на: `{{ post.content_html|safe }}`
- [ ] Удалить фильтр `linebreaks` (больше не нужен)
- [ ] Добавить обертку для стилизации: `<div class="post-content markdown-content">`

### 8. Обновление админки для поддержки Markdown

- [ ] Открыть `blog/admin.py`
- [ ] Добавить поле `content_html` в `readonly_fields`
- [ ] Обновить `fieldsets`:
  - Группа "Основная информация": добавить поле `content`
  - Создать новую группу "HTML предпросмотр" с полем `content_html`
  - Сделать группу сворачиваемой: `"classes": ("collapse",)`
- [ ] Настроить виджет для поля `content` (опционально):
  - Увеличенный textarea или Monaco Editor (Unfold)

### 9. Добавление примера Markdown в help_text

- [ ] Обновить `help_text` для поля `content` в модели
- [ ] Добавить краткую справку по Markdown синтаксису:
  - Заголовки: `# H1`, `## H2`
  - Жирный: `**текст**`
  - Курсив: `*текст*`
  - Код: backticks для inline, тройные для блоков
  - Ссылки: `[текст](url)`
- [ ] Указать, что подсветка кода работает автоматически

### 10. Тестирование конвертации

- [ ] Открыть админку и создать новый тестовый пост
- [ ] Написать Markdown контент:
  - Заголовки разных уровней
  - Списки (маркированные и нумерованные)
  - Блок кода с указанием языка (например, python)
  - Ссылки и изображения (если есть)
  - Жирный и курсивный текст
- [ ] Сохранить пост
- [ ] Проверить в админке:
  - Поле `content_html` заполнилось автоматически
  - HTML корректный (можно посмотреть в readonly поле)
- [ ] Открыть пост на сайте:
  - HTML отображается корректно
  - Структура сохранена (заголовки, списки)
  - Code blocks имеют класс `language-X` (подсветка добавится в Phase 2.4)

### 11. Обновление существующих постов (проверка data migration)

- [ ] Открыть админку и проверить любой старый пост
- [ ] Убедиться, что поле `content_html` заполнено
- [ ] Если пусто — открыть пост, нажать "Сохранить" (без изменений)
- [ ] Проверить, что `content_html` теперь заполнено
- [ ] Альтернатива: запустить management команду для массового обновления

### 12. Создание management команды для регенерации HTML (опционально)

- [ ] Создать файл `blog/management/commands/regenerate_html.py`
- [ ] Реализовать команду:
  - Получить все посты
  - Для каждого вызвать `post.save()` (триггер конвертации)
  - Вывести статистику
- [ ] Добавить параметры:
  - `--post-id` — конвертировать конкретный пост
  - `--all` — все посты
- [ ] Тестировать команду:
  - `python manage.py regenerate_html --all`

## Результат

Работающая система Markdown → HTML:

- Поле `content_html` автоматически заполняется при сохранении
- Все существующие посты сконвертированы
- HTML отображается на фронтенде
- Code blocks имеют правильный класс `language-X` для Highlight.js
- Админка показывает предпросмотр HTML
- Эмодзи, таблицы, footnotes работают (pymdown-extensions)

## Следующий шаг

Фаза 2.4: Подсветка синтаксиса и диаграммы (Highlight.js + Mermaid)

## Возможные проблемы и решения

### Проблема 1: Ошибка импорта markdown

**Причина:** Библиотека не установлена или неправильное имя пакета.

**Решение:**

- Проверить установку: `poetry show markdown`
- Переустановить: `poetry add markdown --force`
- Импортировать правильно: `import markdown` (не `from markdown import ...`)

### Проблема 2: content_html остается пустым

**Причина:** Метод `save()` не вызывается или ошибка в конвертации.

**Решение:**

- Проверить, что `super().save()` вызывается
- Добавить print/logging для отладки
- Проверить, что `content` не пустое при сохранении
- Убедиться, что нет ошибок конвертации (try/except)

### Проблема 3: HTML экранируется в шаблоне

**Причина:** Забыли добавить фильтр `|safe`.

**Решение:**

- Изменить `{{ post.content_html }}` на `{{ post.content_html|safe }}`
- Убедиться, что HTML отображается, а не код

### Проблема 4: Code blocks без класса языка

**Причина:** `codehilite` неправильно настроен или не установлен `use_pygments=False`.

**Решение:**

- Убедиться, что в `extension_configs` установлено `use_pygments: False`
- Проверить, что `lang_prefix: "language-"` настроен
- Пересохранить посты для регенерации HTML
- Проверить HTML в браузере: `<code class="language-python">`

### Проблема 5: Миграция падает с ошибкой

**Причина:** Data migration пытается конвертировать пустые посты.

**Решение:**

- Добавить проверку в функцию `convert_posts()`: `if post.content:`
- Добавить обработку исключений: `try/except`
- Откатить миграцию и исправить: `python manage.py migrate blog <номер_предыдущей_миграции>`

## Проверочный чеклист

После завершения фазы убедитесь:

- [ ] Поле `content_html` существует в базе данных
- [ ] Метод `save()` автоматически конвертирует Markdown
- [ ] Все существующие посты имеют заполненное `content_html`
- [ ] HTML отображается на фронтенде корректно
- [ ] Заголовки, списки, ссылки работают
- [ ] Code blocks имеют класс `language-X` (проверить в DevTools)
- [ ] Админка показывает HTML предпросмотр
- [ ] Создание нового поста с Markdown работает
- [ ] Эмодзи отображаются (если используется `pymdownx.emoji`)

## Дополнительная информация

### Безопасность HTML

На данном этапе доверяем админам — они создают безопасный контент. В будущем (Phase 3+) при добавлении пользовательских комментариев нужно добавить санитизацию через `bleach` для защиты от XSS.

### Расширения pymdown-extensions

Доступные расширения (настраиваются в Phase 2.3):

- **SuperFences** — улучшенные code blocks с поддержкой вложенности и Mermaid
- **Emoji** — эмодзи через `:smile:` синтаксис
- **TaskList** — чекбоксы `- [ ]` и `- [x]`
- **Details** — сворачиваемые блоки `???` (collapsible)
- **Admonitions** — блоки примечаний `!!! note`
- **Keys** — отображение клавиш `++ctrl+c++`

### Гибридный подход: Markdown + Highlight.js

**Преимущества:**

- Легкая база данных (чистый HTML без стилей)
- Гибкие темы (меняются на фронте без регенерации)
- Интерактивные возможности (copy-button, line numbers через плагины)
- Эффектно для YouTube-контента

**Как работает:**

1. Markdown → HTML на сервере (один раз при сохранении)
2. HTML с `<code class="language-python">` сохраняется в базе
3. Highlight.js раскрашивает на клиенте при загрузке страницы

### Производительность

Конвертация Markdown → HTML происходит только при сохранении, поэтому производительность просмотра постов не страдает. HTML уже готов в базе данных.

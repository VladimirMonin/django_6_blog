# Фаза 4.9: Семантический поиск

## Цель

Реализовать векторный поиск по чанкам через pgvector.

---

## Контекст

Семантический поиск находит чанки по смысловой близости к запросу, а не по точному совпадению слов. Алгоритм:

1. Преобразовать запрос пользователя в вектор (через тот же OpenAI API)
2. Найти ближайшие векторы в БД через оператор косинусного расстояния `<=>`
3. Вернуть топ-N результатов с метаданными

pgvector предоставляет индекс **HNSW** (Hierarchical Navigable Small World), который обеспечивает логарифмическое время поиска даже на миллионах векторов.

**Операторы расстояния в pgvector:**

- `<=>` — косинусное расстояние (рекомендуется для эмбеддингов)
- `<->` — L2 (Евклидово) расстояние
- `<#>` — inner product (для SPLADE)

**Философия:** Смысл важнее слов.

**Документация:**

- [Технический отчёт: Chonkie, PostgreSQL, pgvector](../researches/report_6/Технический%20отчет_%20Chonkie,%20Postgresql,%20pgvector.md) — раздел 4.4 "Индексация HNSW"
- [Django, pgvector: семантический поиск локально](../researches/report_6/Django,%20pgvector_%20семантический%20поиск%20локально.md) — раздел 3.2 "Стратегии индексации"

---

## Задачи

### Создание сервиса поиска

- [ ] Создать файл `blog/services/search_service.py`
- [ ] Определить функцию `semantic_search(query: str, limit: int = 10) -> list[SearchResult]`
- [ ] Создать dataclass `SearchResult` с полями: `chunk`, `score`, `post`, `section_title`

### Векторизация запроса

- [ ] Использовать тот же `vectorization_service` для получения эмбеддинга запроса
- [ ] Кэшировать популярные запросы (опционально, для оптимизации)
- [ ] Использовать ту же модель `text-embedding-3-small`

### SQL-запрос поиска

- [ ] Построить запрос с оператором `<=>` для косинусного расстояния
- [ ] Использовать `ORDER BY embedding <=> query_vector`
- [ ] Ограничить результаты `LIMIT`
- [ ] Добавить `select_related('post')` для избежания N+1

### Реализация через Django ORM

- [ ] Использовать `TextChunk.objects.annotate()` с кастомной функцией расстояния
- [ ] Или использовать raw SQL для сложных запросов
- [ ] pgvector-python предоставляет `CosineDistance` для ORM

### Фильтрация результатов

- [ ] Добавить опциональный параметр `chunk_type` для фильтрации по типу
- [ ] Добавить опциональный параметр `post_id` для поиска внутри поста
- [ ] Проблема пост-фильтрации: pgvector 0.8+ поддерживает iterative scans

### Формирование ответа

- [ ] Для каждого найденного чанка вернуть: контент, тип, секцию, ссылку на пост
- [ ] Вычислить score как `1 - cosine_distance` (чем выше, тем лучше)
- [ ] Отсортировать по убыванию score

---

## Тестирование

- [ ] Проиндексировать несколько постов (из фазы 4.8)
- [ ] Выполнить семантический поиск по релевантному запросу
- [ ] Проверить, что результаты соответствуют смыслу запроса
- [ ] Проверить производительность на индексе HNSW

---

## Коммит

```
phase 4.9 feat: Семантический поиск
- Создан blog/services/search_service.py
- Реализована функция semantic_search с pgvector
- Добавлена векторизация поискового запроса
- Поддержка фильтрации по chunk_type и post_id
```
